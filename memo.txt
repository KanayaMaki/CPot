位置はPosition

Windowsの初期化
グラフィックAPIの初期化
インプットの初期化
サウンドの初期化

WinMain
	Game* g = CreateGame();
	g->Setting();

	Application::S().Start();


WindowsGameLoop
	void GameLoop
		Init
		Game.Init

		while(true) {
			Fps.Wait
			Input.Update
			Game.Update
			Game.Render
		}

Game* CreateGame() {
	return new MyGame;
}

Game
	virtual void Setting()
		ゲームが立ち上がってすぐの段階で、画面サイズやそのほかの設定をする
	virtual void Init()
		ゲームの初期化
	virtual void Update()
		ゲームの更新をする
	virtual void Render()
		ゲームの描画をする

class GameMain
	static GameBase* mGame

	static Main() {
		//初期化
		mGame->Init();

		while(true) {
			Input->Update();
			mGame->Update();
			mGame->Render();
			Fps->Wait();

			if(mGameEnd) {
				break;
			}
		}
	}

伝えたいこと
	・ゲームの終了（更新時）
		Win-Game
		Game-Win
	・カーソルを表示するか（更新）
		Game-Win
	・画面サイズ（更新時）
		Game-Win
	・フォーカスがあるか（更新時）
		Win-Game
	・ウィンドウタイトル（更新時）
		Game-Win

class ConfigBase : public Singleton
	CPOT_VI void SetApplicationEnd(BOOL aEnd) CPOT_ZR;
	CPOT_VI BOOL GetApplicationEnd() CPOT_ZR;
	CPOT_VI void SetGameEnd(BOOL aEnd) CPOT_ZR;
	CPOT_VI const CHAR* GetTitle() CPOT_ZR;
	CPOT_VI void SetTitle(const CHAR* aTitle) CPOT_ZR;

	CPOT_VI void SetUseCursor(BOOL aUse) CPOT_ZR;
	CPOT_VI BOOL GetUseCursor() CPOT_ZR;

	CPOT_VI void SetIsActive(BOOL aIsActive) CPOT_ZR;
	CPOT_VI BOOL GetIsActive() CPOT_ZR;

class windows::Config


Window
	if アプリが終わるなら
		SetApplicationEnd(true);

	if GetGameEnd() == true
		//即終了


Setting
	Vector2 mScreenWidth;
	BOOL mUseCursor;
	f32 mFps;
	CHAR* mTitle;

Thread
	Thread t;
	t.Start(DoFunc, data);

	//スレッドの終了を待つ
	t.Join();

	//スレッドを終了する
	t.Stop();


Input
	Input.GetValue(xinput::cLStickLeft);
	Input.GetButton(xinput::cLStickLeft);
	Input.GetButtonDown(ps4::cLStickLeft);
	Input.GetButtonPress(windows::cA);
	Input.GetAxis(xinput::cLStickX);
	Input.GetAxis(ps4::cLStickX);

	Input.GetButton(ps4::CInputCode) {

	}
	Input.GetButton(xinput::CButtonCode) {

	}
	Input.GetButton(windows::CButtonCode) {

	}


File
	class CFileOpenFlag {
	public:
		enum {
			cWrite = 1 << 0,
			cRead = 1 << 1,
			cBinary = 1 << 2,
			cAdd = 1 << 3
		}
	}
	using FileSize = u32;

	FileBase
		OpenToWrite(const CHAR* aFileName, BOOL aIsAdd = false, BOOL aBinary = false);
		OpenToRead(const CHAR* aFileName, BOOL aBinary = false);
		Open(const CHAR* aFileName, BOOL aIsWrite, BOOL aBinary = false, BOOL aIsAdd = false);
		Open(const CHAR* aFileName, u32 aOpenFlags);
		Close();
		u32 Read(BYTE* aBuffer, FileSize aSize);
		u32 Read(Buffer& aBuffer);
		u32 Read(Buffer& aBuffer, FileSize aSize);
		template<FileSize cSize>
		u32 Read(String<cSize>& aStr);
		void Write(const Buffer& aBuffer);
		void Write(const CHAR* aStr, FileSize aSize);
		template<u32 cSize>
		void Write(const String<cSize>& aStr);
		BOOL IsOpen() const;

		FileSize mPosition;
		void SetPosition(FileSize aPosition);
		FileSize GetSize();
		FileSize GetPosition();


描画
インプットの更新

GameLoop：一定の間隔で呼ばれ続ける。入力の更新などを行う
